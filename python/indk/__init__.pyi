"""Type stubs for the indk package."""

from typing import overload

__version__: str

# ---------------------------------------------------------------
# Enums
# ---------------------------------------------------------------

class ComputeBackend:
    NativeCPU: int
    NativeCPUMultithread: int
    OpenCL: int
    Vulkan: int

class CompareFlag:
    Default: int
    Normalized: int

class ProcessingMethod:
    Min: int
    Average: int

class ProcessingMode:
    Default: int
    AutoReset: int
    AutoRollback: int

class OutputMode:
    Stream: int
    Latch: int
    Predefined: int

class ProfilerEvent:
    Processed: int
    Tick: int

# Enum values exported at module level
NativeCPU: int
NativeCPUMultithread: int
OpenCL: int
Vulkan: int
Default: int
Normalized: int
Min: int
Average: int
AutoReset: int
AutoRollback: int
Stream: int
Latch: int
Predefined: int
Processed: int
Tick: int

# ---------------------------------------------------------------
# Data classes
# ---------------------------------------------------------------

class OutputValue:
    @property
    def value(self) -> float: ...
    @property
    def source(self) -> str: ...
    @property
    def time(self) -> int: ...

class ComputeBackendInfo:
    @property
    def backend_id(self) -> int: ...
    @property
    def backend_name(self) -> str: ...
    @property
    def translator_name(self) -> str: ...
    @property
    def ready(self) -> bool: ...

# ---------------------------------------------------------------
# Position
# ---------------------------------------------------------------

class Position:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, xm: int, dimensions: int) -> None: ...
    @overload
    def __init__(self, xm: int, values: list[float]) -> None: ...
    def get_dimensions_count(self) -> int: ...
    def get_xm(self) -> int: ...
    def get_value(self, index: int) -> float: ...
    def get_distance_from(self, other: Position) -> float: ...

# ---------------------------------------------------------------
# Neuron
# ---------------------------------------------------------------

class Neuron:
    @property
    def name(self) -> str: ...
    @property
    def xm(self) -> int: ...
    @property
    def dimensions_count(self) -> int: ...
    @property
    def latency(self) -> int: ...
    @property
    def entries_count(self) -> int: ...
    @property
    def synapses_count(self) -> int: ...
    @property
    def receptors_count(self) -> int: ...
    @property
    def is_learned(self) -> bool: ...
    @property
    def processing_mode(self) -> int: ...
    @property
    def output_mode(self) -> int: ...
    def get_entries(self) -> list[str]: ...
    def get_link_output(self) -> list[str]: ...
    def set_lambda(self, value: float) -> None: ...
    def set_k1(self, value: float) -> None: ...
    def set_k2(self, value: float) -> None: ...
    def set_k3(self, value: float) -> None: ...
    def set_processing_mode(self, mode: int) -> None: ...
    def set_output_mode(self, mode: int) -> None: ...

# ---------------------------------------------------------------
# NeuralNet
# ---------------------------------------------------------------

class NeuralNet:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, path: str) -> None: ...

    # Structure
    def set_structure(self, json_string: str) -> None: ...
    def do_load_structure(self, path: str) -> str: ...
    def get_structure(self, minimized: bool = True) -> str: ...

    # Properties
    @property
    def name(self) -> str: ...
    @property
    def description(self) -> str: ...
    @property
    def version(self) -> str: ...
    @property
    def neuron_count(self) -> int: ...
    @property
    def total_parameter_count(self) -> int: ...
    @property
    def model_size(self) -> int: ...
    @property
    def instance_count(self) -> int: ...
    @property
    def is_learned(self) -> bool: ...

    # Instances
    def do_create_instance(self, backend: int = ...) -> None: ...
    def do_create_instances(self, count: int, backend: int = ...) -> None: ...
    def do_translate_to_instance(self, inputs: list[str] = ..., instance: int = 0) -> None: ...

    # Learn / Recognise
    def do_learn(
        self,
        data: list[list[float]],
        reset: bool = True,
        inputs: list[str] = ...,
        instance: int = 0,
    ) -> list[OutputValue]: ...
    def do_recognise(
        self,
        data: list[list[float]],
        reset: bool = True,
        inputs: list[str] = ...,
        instance: int = 0,
    ) -> list[OutputValue]: ...

    # Compare patterns
    def do_compare_patterns(
        self,
        compare_flag: int = ...,
        processing_method: int = ...,
        instance: int = 0,
    ) -> list[float]: ...
    def do_compare_patterns_ensemble(
        self,
        ensemble: str,
        compare_flag: int = ...,
        processing_method: int = ...,
        instance: int = 0,
    ) -> list[float]: ...
    def do_compare_patterns_neurons(
        self,
        neurons: list[str],
        compare_flag: int = ...,
        processing_method: int = ...,
        instance: int = 0,
    ) -> list[float]: ...

    # Scope
    def do_create_new_scope(self) -> None: ...
    def do_change_scope(self, scope_id: int) -> None: ...

    # Topology
    def do_add_output(self, name: str) -> None: ...
    def do_include_neuron_to_ensemble(self, neuron: str, ensemble: str) -> None: ...
    def do_replicate_neuron(self, from_name: str, to_name: str, integrate: bool) -> Neuron: ...
    def do_delete_neuron(self, name: str) -> None: ...
    def do_replicate_ensemble(self, from_name: str, to_name: str, copy_entries: bool = False) -> None: ...

    # Reset
    def do_reset(self, instance: int) -> None: ...
    def do_reset_ensemble(self, ensemble: str, instance: int) -> None: ...
    def do_reset_neurons(self, neurons: list[str], instance: int) -> None: ...

    # State sync
    def set_state_sync_enabled(self, enabled: bool = True) -> None: ...

    # Neuron access
    def get_neuron(self, name: str) -> Neuron: ...
    def get_neurons(self) -> list[Neuron]: ...
    def get_ensemble(self, name: str) -> list[Neuron]: ...
    def get_output_values(self, neurons: list[str] = ..., instance: int = 0) -> list[OutputValue]: ...

    # Interlink
    def do_interlink_init(self, port: int = 4408, timeout: int = 5) -> None: ...
    def do_interlink_web_init(self, path: str, port: int = 8044) -> None: ...

# ---------------------------------------------------------------
# Module-level functions
# ---------------------------------------------------------------

def get_compute_backends_info() -> list[ComputeBackendInfo]: ...
def is_compute_backend_available(backend_id: int) -> bool: ...
def set_verbosity_level(level: int) -> None: ...
def get_verbosity_level() -> int: ...
def set_cpu_multithread_workers(worker_count: int) -> None: ...
def set_opencl_device(device_name: str) -> None: ...
def set_vulkan_device(device_name: str) -> None: ...
def profiler_attach(net: NeuralNet, event: int, callback: object) -> None: ...

# ---------------------------------------------------------------
# Exception
# ---------------------------------------------------------------

class Error(RuntimeError): ...

# ---------------------------------------------------------------
# Structure helper
# ---------------------------------------------------------------

def structure(definition: dict) -> str: ...
